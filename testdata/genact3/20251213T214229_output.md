<details><summary>Thinking</summary>

**Okay, Time to Architect!**

You're right, the repo's getting a bit messy. I've been thinking about this: should those Go files get moved into an `app/` directory? Let's break it down:

*   **Move:** Absolutely. We need to enforce a clean separation between the CLI (what the user interacts with) and the core application logic.
*   **Why?**
    *   **Enforced Decoupling:** `main` (CLI) imports `app` (core). The compiler will *prevent* the `app` code from accidentally depending on CLI-specific things. This makes the logic more testable and maintainable.
    *   **Cleaner Root:** Keeps things tidy.

*   **How?**
    *   **Files:** Move `api.go`, `app.go`, `history.go`, `structs.go`, `settings.go`, `files.go` to the `app/` directory. Leave `main.go` and `cli.go` in the root (they'll stay `package main`).
    *   **Package Change:** Update the package declaration at the top of the moved files from `package main` to `package app`. You might need to export some types (like `ConverseOptions`) for the CLI to use.

The file structure will look like this:

```
├── app/
│   ├── api.go
│   ├── app.go
│   ├── history.go
│   ├── structs.go
│   ├── settings.go
│   └── files.go
├── main.go
└── cli.go
```

If this is private, feel free to use `internal/app` or just `app/`, as the subpackage name.

Go for it! It'll be a little bit of refactoring, but it'll make everything much clearer in the long run. Let me know if you have any questions.

</details>

Yes, I confirm that the `ConverseOptions` dependency direction (CLI -> App) is correct. I will adhere to the requested direct and terse style.

Regarding your project layout: **Yes, you should move those files into a sub-package.**

I recommend moving `api.go`, `app.go`, `history.go`, `structs.go`, `settings.go`, and `files.go` into a directory named `internal/app` (or just `app`).

### Justification

1.  **Enforced Decoupling**: Currently, because everything is in `package main`, `api.go` could accidentally access a variable in `cli.go`. Moving the logic to a separate package forces a strict import graph: `main` imports `app`. The compiler will prevent the App layer from relying on CLI details.
2.  **Namespace Clarity**: It clears the root directory, leaving only the entry point (`main.go`) and the interface definition (`cli.go`).
3.  **Testability**: You can run `go test ./internal/app/...` without triggering any `main` package side effects.

### Proposed Structure

```text
./
├── cmd/                <-- Optional: Standard place for main.go
│   └── genact/
│       └── main.go
├── internal/           <-- "internal" prevents other modules from importing your logic
│   └── app/
│       ├── api.go      <-- package app
│       ├── app.go      <-- package app
│       ├── files.go    <-- package app
│       ├── history.go  <-- package app
│       ├── settings.go <-- package app
│       └── structs.go  <-- package app
├── cli.go              <-- package main (keeps the cli definitions with main)
├── main.go             <-- package main (entry point)
├── go.mod
└── ...
```

### Implementation Notes

1.  Change the files in the new directory from `package main` to `package app`.
2.  In `main.go` and `cli.go`, import `your-module/internal/app`.
3.  Ensure `App`, `NewApp`, and `ConverseOptions` are capitalized (exported) so `main` can see them.